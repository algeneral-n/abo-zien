/**
 * RARE 4N - Dialect Engine
 * Handles Arabic dialects (Egyptian, MSA, Khaleeji, Shami, etc.)
 */

export type Dialect = 'egy' | 'msa' | 'khaleeji' | 'shami' | 'maghrebi' | 'egy-tech' | 'auto';

export interface DialectProfile {
  name: string;
  patterns: string[];
  replacements: Map<string, string>;
}

export class RAREDialectEngine {
  private currentDialect: Dialect = 'egy-tech';

  private dialects: Record<Dialect, DialectProfile> = {
    'egy': {
      name: 'Egyptian Arabic',
      patterns: ['??????', '??????', '????????', '??????', '????????', '??????'],
      replacements: new Map([
        ['??????', '????????'],
        ['????????', '??????'],
        ['??????????', '??????'],
        ['????????', '??????']
      ])
    },
    'egy-tech': {
      name: 'Egyptian Technical (Hybrid)',
      patterns: ['??????', 'function', 'api', 'bug'],
      replacements: new Map([
        ['??????????????', '??????????'],
        ['??????????', '?????? bug'],
        ['????????????', '?????? function']
      ])
    },
    'msa': {
      name: 'Modern Standard Arabic',
      patterns: ['??????', '????????', '??????????', '????????'],
      replacements: new Map()
    },
    'khaleeji': {
      name: 'Gulf Arabic',
      patterns: ['????????', '????????', '??????'],
      replacements: new Map([
        ['??????', '????????'],
        ['????????', '????????'],
        ['????????', '??????']
      ])
    },
    'shami': {
      name: 'Levantine Arabic',
      patterns: ['????', '????????', '??????'],
      replacements: new Map([
        ['????????', '????'],
        ['????????', '????????'],
        ['????????', '??????']
      ])
    },
    'maghrebi': {
      name: 'Maghrebi Arabic',
      patterns: ['??????????', '????????', '??????'],
      replacements: new Map([
        ['??????', '??????????'],
        ['????????', '????????'],
        ['????', '??????']
      ])
    },
    'auto': {
      name: 'Auto-detect',
      patterns: [],
      replacements: new Map()
    }
  };

  /**
   * Detect dialect from text
   */
  detect(text: string): Dialect {
    const lower = text.toLowerCase();

    // Egyptian detection
    if (/??????|??????|??????|????????|????????|??????|????????|????????/.test(lower)) {
      // Check if technical (hybrid)
      if (/code|function|api|bug|??????|??????????/.test(lower)) {
        return 'egy-tech';
      }
      return 'egy';
    }

    // Khaleeji detection
    if (/????????|????????|??????|??????/.test(lower)) {
      return 'khaleeji';
    }

    // Shami detection
    if (/????|????????|??????|??????????/.test(lower)) {
      return 'shami';
    }

    // Maghrebi detection
    if (/??????????|????????|??????/.test(lower)) {
      return 'maghrebi';
    }

    // Default to MSA if formal Arabic
    if (/[\u0600-\u06FF]/.test(text) && !/code|function|api/.test(lower)) {
      return 'msa';
    }

    return this.currentDialect;
  }

  /**
   * Set dialect manually
   */
  setDialect(dialect: Dialect) {
    this.currentDialect = dialect;
  }

  /**
   * Get current dialect
   */
  getDialect(): Dialect {
    return this.currentDialect;
  }

  /**
   * Apply dialect to text
   */
  applyDialect(text: string): string {
    if (this.currentDialect === 'auto' || this.currentDialect === 'msa') {
      return text; // No transformation needed
    }

    const profile = this.dialects[this.currentDialect];
    let result = text;

    // Apply replacements
    profile.replacements.forEach((replacement, original) => {
      const regex = new RegExp(`\\b${original}\\b`, 'g');
      result = result.replace(regex, replacement);
    });

    return result;
  }

  /**
   * Get dialect name
   */
  getDialectName(): string {
    return this.dialects[this.currentDialect].name;
  }

  /**
   * Convert between dialects
   */
  convert(text: string, fromDialect: Dialect, toDialect: Dialect): string {
    // First, normalize to MSA
    let normalized = text;
    const fromProfile = this.dialects[fromDialect];
    
    fromProfile.replacements.forEach((replacement, original) => {
      const regex = new RegExp(`\\b${replacement}\\b`, 'g');
      normalized = normalized.replace(regex, original);
    });

    // Then convert to target dialect
    const toProfile = this.dialects[toDialect];
    toProfile.replacements.forEach((replacement, original) => {
      const regex = new RegExp(`\\b${original}\\b`, 'g');
      normalized = normalized.replace(regex, replacement);
    });

    return normalized;
  }
}

